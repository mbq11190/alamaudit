#!/usr/bin/env python3
"""Generate a candidate, commented SQL patch based on DB evidence (when provided) and repo models.
This produces a safe, reversible set of SQL actions (disabled by default / commented) to:
 - archive/flag ir_model rows not defined by the repo
 - disable crons and server actions referencing missing models
 - set modules found in repo to 'to upgrade' state so registry picks them up during upgrades
Usage:
  python scripts/generate_candidate_patch.py --out scripts/candidate_patch.sql [--db <dbname>] [--psql psql]
  python scripts/generate_candidate_patch.py --db <dbname> --apply  # Apply after confirmation (dangerous!)

The script is intentionally conservative: it writes commented SQL and an UNDO section. Use the safe orchestrator or review manually before applying.
"""
import argparse
import subprocess
import shlex
from pathlib import Path
import sys

ROOT = Path(__file__).resolve().parents[1]
SCRIPTS = ROOT / 'scripts'
SCRIPTS.mkdir(exist_ok=True)

parser = argparse.ArgumentParser()
parser.add_argument('--db', help='Database name to query (optional)')
parser.add_argument('--psql', default='psql', help='psql executable')
parser.add_argument('--out', default=str(SCRIPTS / 'candidate_patch.sql'))
parser.add_argument('--apply', action='store_true', help='Apply the patch to DB (requires --db)')
args = parser.parse_args()

out_path = Path(args.out)

# load repo models
repo_models = []
try:
    out = subprocess.check_output([sys.executable, str(SCRIPTS / 'compare_repo_models.py')], stderr=subprocess.DEVNULL)
    repo_models = [l.strip() for l in out.decode('utf-8').splitlines() if l.strip()]
except Exception:
    # fallback to local script
    try:
        out = subprocess.check_output([sys.executable, str(ROOT / 'scripts' / 'compare_repo_models.py')])
        repo_models = [l.strip() for l in out.decode('utf-8').splitlines() if l.strip()]
    except Exception:
        repo_models = []

lines = []
lines.append('-- Candidate Patch (COMMENTED by default)')
lines.append('-- Generated by scripts/generate_candidate_patch.py')
lines.append('-- Review carefully before applying. Use --db <dbname> to include DB-driven suggestions.\n')

if args.db:
    lines.append(f'-- DB evidence collection for: {args.db}\n')
    def run_psql(q):
        cmd = f"{args.psql} -d {shlex.quote(args.db)} -t -c {shlex.quote(q)}"
        try:
            out = subprocess.check_output(cmd, shell=True, stderr=subprocess.DEVNULL)
            return out.decode('utf-8').strip()
        except subprocess.CalledProcessError:
            return ''

    # 1) DB-only models (present in DB but not in repo)
    db_models_out = run_psql("SELECT model FROM ir_model ORDER BY model;")
    db_models = [l.strip() for l in db_models_out.splitlines() if l.strip()]

    candidates = [m for m in db_models if m not in repo_models]
    if candidates:
        lines.append('-- Models present in DB but not in repo (candidates to archive/review):')
        for m in candidates:
            lines.append(f'--   {m}')
        lines.append('\n')
        lines.append('-- Suggestion: archive these models into a review table for manual inspection')
        lines.append("-- CREATE TABLE IF NOT EXISTS scripts_ir_model_review (id serial primary key, model text, notes text, created_at timestamptz default now());")
        for m in candidates:
            safe_m = m.replace("'", "''")
            lines.append("-- INSERT INTO scripts_ir_model_review (model, notes) VALUES ('" + safe_m + "', 'candidate for review by generate_candidate_patch');")
        lines.append('-- UNDO: DELETE FROM scripts_ir_model_review WHERE model IN (...);\n')

    # 2) Crons referencing models not in repo
    crons_out = run_psql("SELECT id, name, model FROM ir_cron WHERE model IS NOT NULL ORDER BY id;")
    crons = []
    for ln in crons_out.splitlines():
        if ln.strip():
            parts = ln.strip().split('|')
            if len(parts) >= 3:
                cid = parts[0].strip()
                name = parts[1].strip()
                model = parts[2].strip()
                if model and model not in repo_models:
                    crons.append((cid, name, model))
    if crons:
        lines.append('-- Crons referencing models missing in repo:')
        for cid, name, model in crons:
            lines.append(f"--   id={cid} name='{name}' model='{model}'")
        lines.append('\n')
        lines.append("-- Suggested action: disable these crons until underlying models are restored or modules installed")
        for cid, name, model in crons:
            lines.append(f"-- UPDATE ir_cron SET active = false WHERE id = {cid};  -- UNDO: UPDATE ir_cron SET active = true WHERE id = {cid};")
        lines.append('\n')

    # 3) Server actions referencing missing models
    sa_out = run_psql("SELECT id, name, model FROM ir_actions_server ORDER BY id;")
    sas = []
    for ln in sa_out.splitlines():
        if ln.strip():
            parts = ln.strip().split('|')
            if len(parts) >= 3:
                aid = parts[0].strip()
                name = parts[1].strip()
                model = parts[2].strip()
                if model and model not in repo_models:
                    sas.append((aid, name, model))
    if sas:
        lines.append('-- Server actions referencing models missing in repo:')
        for aid, name, model in sas:
            lines.append(f"--   id={aid} name='{name}' model='{model}'")
        lines.append('\n')
        lines.append("-- Suggested action: set state='code' and set code to inert placeholder, or disable the action")
        for aid, name, model in sas:
            lines.append(f"-- UPDATE ir_actions_server SET state = 'code', code = 'raise Warning(\'Server action disabled pending model restoration\')' WHERE id = {aid}; -- UNDO: restore from backup")
        lines.append('\n')

    # 4) Modules present in repo but not installed: suggest to set state='to upgrade' or 'to install'
    modules_out = run_psql("SELECT name, state FROM ir_module_module ORDER BY name;")
    modules = [l.strip() for l in modules_out.splitlines() if l.strip()]
    repo_module_candidates = []
    # Heuristic: map repo module directory names to module names by checking manifests
    # Simpler: suggest a few qaco modules known to be present
    repo_candidates = ['qaco_audit','qaco_employees','qaco_client_onboarding','qaco_execution_phase','qaco_planning_phase','qaco_deliverables','web_responsive']
    lines.append('-- Suggest bringing repo modules into to-upgrade state (review list below)')
    for mod in repo_candidates:
        lines.append(f"-- UPDATE ir_module_module SET state = 'to upgrade' WHERE name = '{mod}';  -- UNDO: set to 'installed' or previous state if needed")
    lines.append('\n')

else:
    lines.append('-- No DB provided. Run with --db <dbname> to produce DB-driven candidate patch suggestions.\n')

# Append general safe non-destructive items
lines.append('-- Additional safe suggestions (manual review recommended):')
lines.append("-- 1) Ensure 'web_responsive' is installed and loaded to avoid 'is_redirect_home' errors. If the field was missing in DB and code provides it, install or upgrade the module.")
lines.append("-- 2) Do not delete ir_model rows without manual verification; use the review table approach above.")
lines.append('\n')

# Write outputs
out_path.write_text('\n'.join(lines), encoding='utf-8')
report_path = SCRIPTS / 'candidate_patch_report.txt'
report_path.write_text('\n'.join(lines), encoding='utf-8')

print(f'Candidate patch written to: {out_path}')
print(f'Report written to: {report_path}')

# Apply option (dangerous)
if args.apply:
    if not args.db:
        print('ERROR: --apply requires --db <dbname> to be specified', file=sys.stderr)
        sys.exit(1)
    confirm = input('Type YES to apply the candidate patch SQL to DB (this will execute commented SQL): ')
    if confirm == 'YES':
        print('Applying SQL...')
        subprocess.check_call([args.psql, '-d', args.db, '-f', str(out_path)])
        print('Applied candidate patch')
    else:
        print('Apply aborted by user')
